"""
This module uses COLMAP to solve camera poses and initialize point clouds 
from videos generated by GEN3C. The results are used for subsequent Gaussian splatting reconstruction.

Output:
    Running this script generates the following files and directories under 
    3d_result/{scene_name}/stage1_reconstruction/:
    - merged_video.mp4: Merged video file from left and right rotation videos
    - 3d/images/: Directory containing merged images for COLMAP processing
    - 3d/sparse/: Directory containing COLMAP sparse reconstruction results (cameras, images, points3D)
    - 3d/stats/: Directory containing reconstruction statistics
    - 3d/tb/: Directory containing tensorboard logs
"""

import os
import subprocess
import argparse
import shutil
import cv2
from pathlib import Path

def merge_images(input_dir1, input_dir2, output_dir):
    """
    Merge images from two input directories to output_dir/3d/images
    Images from dir1 are in reverse order, images from dir2 are in normal order
    All images are renamed from 0-N
    """
    images_dir = os.path.join(output_dir, '3d', 'images')
    os.makedirs(images_dir, exist_ok=True)

    def get_number(filename):
        return int(''.join(filter(str.isdigit, filename)))

    images1 = sorted(
        [f for f in os.listdir(input_dir1) if f.endswith(('.jpg', '.png', '.jpeg'))],
        key=get_number,
        reverse=True
    )
    images2 = sorted(
        [f for f in os.listdir(input_dir2) if f.endswith(('.jpg', '.png', '.jpeg'))],
        key=get_number
    )

    idx = 0
    for img in images1:
        src = os.path.join(input_dir1, img)
        dst = os.path.join(images_dir, f'{idx:06d}.jpg')
        shutil.copy2(src, dst)
        idx += 1

    for img in images2:
        src = os.path.join(input_dir2, img)
        dst = os.path.join(images_dir, f'{idx:06d}.jpg')
        shutil.copy2(src, dst)
        idx += 1

    return images_dir

def create_video(images_dir, output_dir, fps=30):
    """
    Create video from image sequence
    """
    images = sorted(
        [f for f in os.listdir(images_dir) if f.endswith(('.jpg', '.png', '.jpeg'))],
        key=lambda x: int(os.path.splitext(x)[0])
    )

    if not images:
        raise ValueError("No image files found")

    first_image = cv2.imread(os.path.join(images_dir, images[0]))
    height, width = first_image.shape[:2]

    video_path = os.path.join(output_dir, 'merged_video.mp4')
    fourcc = cv2.VideoWriter_fourcc(*'mp4v')
    video_writer = cv2.VideoWriter(video_path, fourcc, fps, (width, height))

    print("\nGenerating video...")
    for i, img_name in enumerate(images):
        img_path = os.path.join(images_dir, img_name)
        frame = cv2.imread(img_path)
        if frame is not None:
            video_writer.write(frame)
            print(f"\rProgress: {i+1}/{len(images)}", end="", flush=True)
        else:
            print(f"\nWarning: Unable to read image {img_path}")

    video_writer.release()
    print(f"\nVideo generated: {video_path}")
    return video_path

def copy_images(input_dir, output_dir):
    """
    Copy images from input directory to output_dir/3d/images
    """
    images_dir = os.path.join(output_dir, '3d', 'images')
    os.makedirs(images_dir, exist_ok=True)
    
    for img in os.listdir(input_dir):
        if img.endswith(('.jpg', '.png', '.jpeg')):
            src = os.path.join(input_dir, img)
            dst = os.path.join(images_dir, img)
            shutil.copy2(src, dst)
    
    return images_dir

def run_command(command):
    """Run command and display output in real-time"""
    process = subprocess.Popen(
        command,
        stdout=subprocess.PIPE,
        stderr=subprocess.STDOUT,
        text=False,
        bufsize=1
    )
    
    while True:
        output = process.stdout.readline()
        if not output and process.poll() is not None:
            break
        if output:
            try:
                line = output.decode('utf-8', errors='ignore')
                print(line.strip())
            except:
                print(".", end="", flush=True)
    
    rc = process.poll()
    if rc != 0:
        raise subprocess.CalledProcessError(rc, command)

def run_colmap(images_dir, workspace_dir, use_gpu=True):
    """
    Run COLMAP reconstruction with core parameter settings
    """
    print("\nStarting COLMAP reconstruction...")
    print(f"Workspace: {workspace_dir}")
    print(f"Image directory: {images_dir}")
    print(f"Use GPU: {'Yes' if use_gpu else 'No'}")

    sparse_dir = os.path.join(workspace_dir, '3d', 'sparse')
    os.makedirs(sparse_dir, exist_ok=True)
    
    database_path = os.path.join(workspace_dir, 'database.db')
    
    if os.path.exists(database_path):
        os.remove(database_path)
        
    print("\n1. Feature extraction...")
    feature_extractor_cmd = [
        'colmap', 'feature_extractor',
        '--database_path', database_path,
        '--image_path', images_dir,
        '--ImageReader.camera_model', 'SIMPLE_RADIAL',
        '--ImageReader.single_camera', '1',
        '--SiftExtraction.use_gpu', '1' if use_gpu else '0',
        '--SiftExtraction.max_num_features', '16384',
        '--SiftExtraction.peak_threshold', '0.004'
    ]
    run_command(feature_extractor_cmd)

    print("\n2. Feature matching...")
    matcher_cmd = [
        'colmap', 'sequential_matcher',
        '--database_path', database_path,
        '--SiftMatching.use_gpu', '1' if use_gpu else '0',
        '--SequentialMatching.overlap', '50',
        '--SequentialMatching.quadratic_overlap', '1'
    ]
    run_command(matcher_cmd)

    print("\n3. Sparse reconstruction...")
    mapper_cmd = [
        'colmap', 'mapper',
        '--database_path', database_path,
        '--image_path', images_dir,
        '--output_path', sparse_dir,
        '--Mapper.min_num_matches', '8',
        '--Mapper.init_min_tri_angle', '3',
        '--Mapper.multiple_models', '1',
        '--Mapper.extract_colors', '1'
    ]
    run_command(mapper_cmd)

    print(f"\nCOLMAP reconstruction completed.")
    print(f"Results saved to: {sparse_dir}")
    
    if not os.path.exists(os.path.join(sparse_dir, '0')):
        print("\nWarning: No reconstruction results found, reconstruction may have failed.")
        return False
    return True

def main():
    parser = argparse.ArgumentParser(description='Merge two image folders and generate video')
    parser.add_argument('--input_dir1', help='First input image folder (will be reversed)')
    parser.add_argument('--input_dir2', help='Second input image folder', default=None)
    parser.add_argument('--output_dir', help='Output directory')
    parser.add_argument('--fps', type=int, default=30, help='Video frame rate')
    
    args = parser.parse_args()
    if args.input_dir2 is not None:
        input_dir1 = Path(args.input_dir1).resolve()
        input_dir2 = Path(args.input_dir2).resolve()
        output_dir = Path(args.output_dir).resolve()

        os.makedirs(output_dir, exist_ok=True)

        images_dir = merge_images(input_dir1, input_dir2, output_dir)

        create_video(images_dir, output_dir, args.fps)
    else:
        images_dir = args.input_dir1
        output_dir = args.output_dir
    run_colmap(images_dir, output_dir)

if __name__ == "__main__":
    main()